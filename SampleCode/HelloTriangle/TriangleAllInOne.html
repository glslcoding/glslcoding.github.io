<html>

<head>
    <!--
    <script id="vertex-shader" type="x-shader/x-vertex">
        attribute vec4 vPosition; 
        void main() 
        { 
            gl_Position = vPosition; 
        }
    </script>

    <script id="fragment-shader" type="x-shader/x-fragment">
        precision mediump float; 
        void main() 
        { 
            gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 ); 
        }
    </script>
    -->
    

    <script type="text/javascript">
    
        
        var vertexShaderText = 
        [
        'attribute vec4 vPosition;', 
        'void main()', 
        '{ ',
        '   gl_Position = vPosition;', 
        '}',
        ].join('\n');

        var fragmentShaderText =
        [
        'precision mediump float;', 
        'void main()', 
        '{ ',
         '   gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );', 
        '}',
        ].join('\n');
        
    
        var RunWebGL = function()
        {
            var canvas = document.getElementById("webGL-canvas");
            var gl = canvas.getContext("webgl") ||
                    canvas.getContext("experimental-webgl");
            if (!gl)
            {
                console.log("Browser doesnt support webGL");
                return;        
            }
           
                        
      
            /*
            var vertElem = document.getElementById( "vertex-shader" );
           
            if ( !vertElem ) { 
                alert( "Unable to load vertex shader " + vertexShaderId );
                return -1;
            }


            var fragElem = document.getElementById( "fragment-shader" );
            if ( !fragElem ) { 
                alert( "Unable to load vertex shader " + fragmentShaderId );
                return -1;
            }         
            */
            
            var vertexShader = gl.createShader(gl.VERTEX_SHADER);
            var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);

            gl.shaderSource(vertexShader, vertexShaderText);
            gl.shaderSource(fragmentShader, fragmentShaderText);

            gl.compileShader(vertexShader);
            if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {
                console.error('ERROR compiling vertex shader!', gl.getShaderInfoLog(vertexShader));
                return;
            }

            gl.compileShader(fragmentShader);
            if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {
                console.error('ERROR compiling fragment shader!', gl.getShaderInfoLog(fragmentShader));
                return;
            }

            var program = gl.createProgram();
            
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            gl.linkProgram(program);
            
            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                console.error('ERROR linking program!', gl.getProgramInfoLog(program));
                return;
            }
            gl.validateProgram(program);
            if (!gl.getProgramParameter(program, gl.VALIDATE_STATUS)) {
                console.error('ERROR validating program!', gl.getProgramInfoLog(program));
                return;
            }

            // create vertex data -- CPU site
            var vertices = [
                // position color
                -1.0, -1.0, 
                0.0, 1.0,  
                1.0, -1.0
            ];
            
            var triangleVBO = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, triangleVBO);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices),gl.STATIC_DRAW);
            
            
            var positionAttribLocation = gl.getAttribLocation(program, "vPosition");
                       
            gl.vertexAttribPointer(
                positionAttribLocation, // Attribute location
                2, // Number of elements per attribute
                gl.FLOAT, // Type of elements
                gl.FALSE,
                2 * Float32Array.BYTES_PER_ELEMENT, // Size of an individual vertex
                0//3 * Float32Array.BYTES_PER_ELEMENT //Offset from the beginning of a single vertex to this attribute
            );
           
            gl.enableVertexAttribArray(positionAttribLocation);
     
     
            //set clear color
            gl.clearColor(0.8, 0.6, 0.2, 1.0);
            
            //clear color buffer using color above
            gl.clear(gl.COLOR_BUFFER_BIT);  
            
            //
            // Main render loop
            //
            gl.useProgram(program);
            gl.drawArrays(gl.TRIANGLES, 0, 3);
        
        }
    </script>
</head>

<body onload="RunWebGL()">
    <div align = "center">
        <canvas id="webGL-canvas" width="800" height="600"></canvas>
    </div>
</body>

</html>